From ac39fe3d341cc33dfd5f47d5301c2a6aaf743a34 Mon Sep 17 00:00:00 2001
From: Alyssa Ross <hi@alyssa.is>
Date: Fri, 2 Apr 2021 17:55:55 +0000
Subject: [PATCH 4/4] Revert "Revert "vm_tools: sommelier: Switch to the stable
 version of xdg-shell""

This reverts commit 32050c0ea6c00c16999915856b40a6a6b8b41bb9.
---
 vm_tools/sommelier/BUILD.gn                   |   2 +-
 vm_tools/sommelier/meson.build                |   2 +-
 ...dg-shell-unstable-v6.xml => xdg-shell.xml} | 435 +++++++++++++-----
 vm_tools/sommelier/sommelier-xdg-shell.cc     | 217 +++++----
 vm_tools/sommelier/sommelier.cc               | 210 +++++----
 vm_tools/sommelier/sommelier.h                |   8 +-
 6 files changed, 535 insertions(+), 339 deletions(-)
 rename vm_tools/sommelier/protocol/{xdg-shell-unstable-v6.xml => xdg-shell.xml} (71%)

diff --git a/vm_tools/sommelier/BUILD.gn b/vm_tools/sommelier/BUILD.gn
index 52df0e3403..fe543138ef 100644
--- a/vm_tools/sommelier/BUILD.gn
+++ b/vm_tools/sommelier/BUILD.gn
@@ -49,7 +49,7 @@ wayland_protocol_library("sommelier-protocol") {
     "protocol/relative-pointer-unstable-v1.xml",
     "protocol/text-input-unstable-v1.xml",
     "protocol/viewporter.xml",
-    "protocol/xdg-shell-unstable-v6.xml",
+    "protocol/xdg-shell.xml",
   ]
 }
 
diff --git a/vm_tools/sommelier/meson.build b/vm_tools/sommelier/meson.build
index 088e3e173f..86bcced912 100644
--- a/vm_tools/sommelier/meson.build
+++ b/vm_tools/sommelier/meson.build
@@ -58,7 +58,7 @@ wl_protocols = [
     'protocol/relative-pointer-unstable-v1.xml',
     'protocol/text-input-unstable-v1.xml',
     'protocol/viewporter.xml',
-    'protocol/xdg-shell-unstable-v6.xml',
+    'protocol/xdg-shell.xml',
 ]
 
 wl_outs = []
diff --git a/vm_tools/sommelier/protocol/xdg-shell-unstable-v6.xml b/vm_tools/sommelier/protocol/xdg-shell.xml
similarity index 71%
rename from vm_tools/sommelier/protocol/xdg-shell-unstable-v6.xml
rename to vm_tools/sommelier/protocol/xdg-shell.xml
index 1c0f92452b..f7377a713c 100644
--- a/vm_tools/sommelier/protocol/xdg-shell-unstable-v6.xml
+++ b/vm_tools/sommelier/protocol/xdg-shell.xml
@@ -1,11 +1,13 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<protocol name="xdg_shell_unstable_v6">
+<protocol name="xdg_shell">
 
   <copyright>
     Copyright © 2008-2013 Kristian Høgsberg
     Copyright © 2013      Rafael Antognolli
     Copyright © 2013      Jasper St. Pierre
     Copyright © 2010-2013 Intel Corporation
+    Copyright © 2015-2017 Samsung Electronics Co., Ltd
+    Copyright © 2015-2017 Red Hat Inc.
 
     Permission is hereby granted, free of charge, to any person obtaining a
     copy of this software and associated documentation files (the "Software"),
@@ -27,18 +29,19 @@
     DEALINGS IN THE SOFTWARE.
   </copyright>
 
-  <interface name="zxdg_shell_v6" version="1">
+  <interface name="xdg_wm_base" version="3">
     <description summary="create desktop-style surfaces">
-      xdg_shell allows clients to turn a wl_surface into a "real window"
-      which can be dragged, resized, stacked, and moved around by the
-      user. Everything about this interface is suited towards traditional
-      desktop environments.
+      The xdg_wm_base interface is exposed as a global object enabling clients
+      to turn their wl_surfaces into windows in a desktop environment. It
+      defines the basic functionality needed for clients and the compositor to
+      create windows that can be dragged, resized, maximized, etc, as well as
+      creating transient windows such as popup menus.
     </description>
 
     <enum name="error">
       <entry name="role" value="0" summary="given wl_surface has another role"/>
       <entry name="defunct_surfaces" value="1"
-	     summary="xdg_shell was destroyed before children"/>
+	     summary="xdg_wm_base was destroyed before children"/>
       <entry name="not_the_topmost_popup" value="2"
 	     summary="the client tried to map or destroy a non-topmost popup"/>
       <entry name="invalid_popup_parent" value="3"
@@ -50,11 +53,11 @@
     </enum>
 
     <request name="destroy" type="destructor">
-      <description summary="destroy xdg_shell">
-	Destroy this xdg_shell object.
+      <description summary="destroy xdg_wm_base">
+	Destroy this xdg_wm_base object.
 
-	Destroying a bound xdg_shell object while there are surfaces
-	still alive created by this xdg_shell object instance is illegal
+	Destroying a bound xdg_wm_base object while there are surfaces
+	still alive created by this xdg_wm_base object instance is illegal
 	and will result in a protocol error.
       </description>
     </request>
@@ -65,7 +68,7 @@
 	surfaces relative to some parent surface. See the interface description
 	and xdg_surface.get_popup for details.
       </description>
-      <arg name="id" type="new_id" interface="zxdg_positioner_v6"/>
+      <arg name="id" type="new_id" interface="xdg_positioner"/>
     </request>
 
     <request name="get_xdg_surface">
@@ -82,14 +85,14 @@
 	See the documentation of xdg_surface for more details about what an
 	xdg_surface is and how it is used.
       </description>
-      <arg name="id" type="new_id" interface="zxdg_surface_v6"/>
+      <arg name="id" type="new_id" interface="xdg_surface"/>
       <arg name="surface" type="object" interface="wl_surface"/>
     </request>
 
     <request name="pong">
       <description summary="respond to a ping event">
 	A client must respond to a ping event with a pong request or
-	the client may be deemed unresponsive. See xdg_shell.ping.
+	the client may be deemed unresponsive. See xdg_wm_base.ping.
       </description>
       <arg name="serial" type="uint" summary="serial of the ping event"/>
     </request>
@@ -98,7 +101,7 @@
       <description summary="check if the client is alive">
 	The ping event asks the client if it's still alive. Pass the
 	serial specified in the event back to the compositor by sending
-	a "pong" request back with the specified serial. See xdg_shell.ping.
+	a "pong" request back with the specified serial. See xdg_wm_base.pong.
 
 	Compositors can use this to determine if the client is still
 	alive. It's unspecified what will happen if the client doesn't
@@ -106,13 +109,13 @@
 	try to respond in a reasonable amount of time.
 
 	A compositor is free to ping in any way it wants, but a client must
-	always respond to any xdg_shell object it created.
+	always respond to any xdg_wm_base object it created.
       </description>
       <arg name="serial" type="uint" summary="pass this to the pong request"/>
     </event>
   </interface>
 
-  <interface name="zxdg_positioner_v6" version="1">
+  <interface name="xdg_positioner" version="3">
     <description summary="child surface positioner">
       The xdg_positioner provides a collection of rules for the placement of a
       child surface relative to a parent surface. Rules can be defined to ensure
@@ -162,13 +165,13 @@
 	Specify the anchor rectangle within the parent surface that the child
 	surface will be placed relative to. The rectangle is relative to the
 	window geometry as defined by xdg_surface.set_window_geometry of the
-	parent surface. The rectangle must be at least 1x1 large.
+	parent surface.
 
 	When the xdg_positioner object is used to position a child surface, the
 	anchor rectangle may not extend outside the window geometry of the
 	positioned child's parent surface.
 
-	If a zero or negative size is set the invalid_input error is raised.
+	If a negative size is set the invalid_input error is raised.
       </description>
       <arg name="x" type="int" summary="x position of anchor rectangle"/>
       <arg name="y" type="int" summary="y position of anchor rectangle"/>
@@ -176,63 +179,54 @@
       <arg name="height" type="int" summary="height of anchor rectangle"/>
     </request>
 
-    <enum name="anchor" bitfield="true">
-      <entry name="none" value="0"
-	     summary="the center of the anchor rectangle"/>
-      <entry name="top" value="1"
-	     summary="the top edge of the anchor rectangle"/>
-      <entry name="bottom" value="2"
-	     summary="the bottom edge of the anchor rectangle"/>
-      <entry name="left" value="4"
-	     summary="the left edge of the anchor rectangle"/>
-      <entry name="right" value="8"
-	     summary="the right edge of the anchor rectangle"/>
+    <enum name="anchor">
+      <entry name="none" value="0"/>
+      <entry name="top" value="1"/>
+      <entry name="bottom" value="2"/>
+      <entry name="left" value="3"/>
+      <entry name="right" value="4"/>
+      <entry name="top_left" value="5"/>
+      <entry name="bottom_left" value="6"/>
+      <entry name="top_right" value="7"/>
+      <entry name="bottom_right" value="8"/>
     </enum>
 
     <request name="set_anchor">
-      <description summary="set anchor rectangle anchor edges">
-	Defines a set of edges for the anchor rectangle. These are used to
-	derive an anchor point that the child surface will be positioned
-	relative to. If two orthogonal edges are specified (e.g. 'top' and
-	'left'), then the anchor point will be the intersection of the edges
-	(e.g. the top left position of the rectangle); otherwise, the derived
-	anchor point will be centered on the specified edge, or in the center of
-	the anchor rectangle if no edge is specified.
-
-	If two parallel anchor edges are specified (e.g. 'left' and 'right'),
-	the invalid_input error is raised.
+      <description summary="set anchor rectangle anchor">
+	Defines the anchor point for the anchor rectangle. The specified anchor
+	is used derive an anchor point that the child surface will be
+	positioned relative to. If a corner anchor is set (e.g. 'top_left' or
+	'bottom_right'), the anchor point will be at the specified corner;
+	otherwise, the derived anchor point will be centered on the specified
+	edge, or in the center of the anchor rectangle if no edge is specified.
       </description>
       <arg name="anchor" type="uint" enum="anchor"
-	   summary="bit mask of anchor edges"/>
+	   summary="anchor"/>
     </request>
 
-    <enum name="gravity" bitfield="true">
-      <entry name="none" value="0"
-	     summary="center over the anchor edge"/>
-      <entry name="top" value="1"
-	     summary="position above the anchor edge"/>
-      <entry name="bottom" value="2"
-	     summary="position below the anchor edge"/>
-      <entry name="left" value="4"
-	     summary="position to the left of the anchor edge"/>
-      <entry name="right" value="8"
-	     summary="position to the right of the anchor edge"/>
+    <enum name="gravity">
+      <entry name="none" value="0"/>
+      <entry name="top" value="1"/>
+      <entry name="bottom" value="2"/>
+      <entry name="left" value="3"/>
+      <entry name="right" value="4"/>
+      <entry name="top_left" value="5"/>
+      <entry name="bottom_left" value="6"/>
+      <entry name="top_right" value="7"/>
+      <entry name="bottom_right" value="8"/>
     </enum>
 
     <request name="set_gravity">
       <description summary="set child surface gravity">
 	Defines in what direction a surface should be positioned, relative to
-	the anchor point of the parent surface. If two orthogonal gravities are
-	specified (e.g. 'bottom' and 'right'), then the child surface will be
-	placed in the specified direction; otherwise, the child surface will be
-	centered over the anchor point on any axis that had no gravity
-	specified.
-
-	If two parallel gravities are specified (e.g. 'left' and 'right'), the
-	invalid_input error is raised.
+	the anchor point of the parent surface. If a corner gravity is
+	specified (e.g. 'bottom_right' or 'top_left'), then the child surface
+	will be placed towards the specified gravity; otherwise, the child
+	surface will be centered over the anchor point on any axis that had no
+	gravity specified.
       </description>
       <arg name="gravity" type="uint" enum="gravity"
-	   summary="bit mask of gravity directions"/>
+	   summary="gravity direction"/>
     </request>
 
     <enum name="constraint_adjustment" bitfield="true">
@@ -252,7 +246,7 @@
       <entry name="none" value="0">
 	<description summary="don't move the child surface when constrained">
 	  Don't alter the surface position even if it is constrained on some
-	  axis, for example partially outside the edge of a monitor.
+	  axis, for example partially outside the edge of an output.
 	</description>
       </entry>
       <entry name="slide_x" value="1">
@@ -304,6 +298,10 @@
 	  surface is constrained, the gravity is 'bottom' and the anchor is
 	  'bottom', change the gravity to 'top' and the anchor to 'top'.
 
+	  The adjusted position is calculated given the original anchor
+	  rectangle and offset, but with the new flipped anchor and gravity
+	  values.
+
 	  If the adjusted position also ends up being constrained, the resulting
 	  position of the flip_y adjustment will be the one before the
 	  adjustment.
@@ -359,9 +357,49 @@
       <arg name="x" type="int" summary="surface position x offset"/>
       <arg name="y" type="int" summary="surface position y offset"/>
     </request>
+
+    <!-- Version 3 additions -->
+
+    <request name="set_reactive" since="3">
+      <description summary="continuously reconstrain the surface">
+	When set reactive, the surface is reconstrained if the conditions used
+	for constraining changed, e.g. the parent window moved.
+
+	If the conditions changed and the popup was reconstrained, an
+	xdg_popup.configure event is sent with updated geometry, followed by an
+	xdg_surface.configure event.
+      </description>
+    </request>
+
+    <request name="set_parent_size" since="3">
+      <description summary="">
+	Set the parent window geometry the compositor should use when
+	positioning the popup. The compositor may use this information to
+	determine the future state the popup should be constrained using. If
+	this doesn't match the dimension of the parent the popup is eventually
+	positioned against, the behavior is undefined.
+
+	The arguments are given in the surface-local coordinate space.
+      </description>
+      <arg name="parent_width" type="int"
+	   summary="future window geometry width of parent"/>
+      <arg name="parent_height" type="int"
+	   summary="future window geometry height of parent"/>
+    </request>
+
+    <request name="set_parent_configure" since="3">
+      <description summary="set parent configure this is a response to">
+	Set the serial of a xdg_surface.configure event this positioner will be
+	used in response to. The compositor may use this information together
+	with set_parent_size to determine what future state the popup should be
+	constrained using.
+      </description>
+      <arg name="serial" type="uint"
+	   summary="serial of parent configure event"/>
+    </request>
   </interface>
 
-  <interface name="zxdg_surface_v6" version="1">
+  <interface name="xdg_surface" version="3">
     <description summary="desktop user interface surface base interface">
       An interface that may be implemented by a wl_surface, for
       implementations that provide a desktop-style user interface.
@@ -388,11 +426,25 @@
       manipulate a buffer prior to the first xdg_surface.configure call must
       also be treated as errors.
 
-      For a surface to be mapped by the compositor, the following conditions
-      must be met: (1) the client has assigned a xdg_surface based role to the
-      surface, (2) the client has set and committed the xdg_surface state and
-      the role dependent state to the surface and (3) the client has committed a
-      buffer to the surface.
+      After creating a role-specific object and setting it up, the client must
+      perform an initial commit without any buffer attached. The compositor
+      will reply with an xdg_surface.configure event. The client must
+      acknowledge it and is then allowed to attach a buffer to map the surface.
+
+      Mapping an xdg_surface-based role surface is defined as making it
+      possible for the surface to be shown by the compositor. Note that
+      a mapped surface is not guaranteed to be visible once it is mapped.
+
+      For an xdg_surface to be mapped by the compositor, the following
+      conditions must be met:
+      (1) the client has assigned an xdg_surface-based role to the surface
+      (2) the client has set and committed the xdg_surface state and the
+	  role-dependent state to the surface
+      (3) the client has committed a buffer to the surface
+
+      A newly-unmapped surface is considered to have met condition (1) out
+      of the 3 required conditions for mapping a surface if its role surface
+      has not been destroyed.
     </description>
 
     <enum name="error">
@@ -416,20 +468,23 @@
 	See the documentation of xdg_toplevel for more details about what an
 	xdg_toplevel is and how it is used.
       </description>
-      <arg name="id" type="new_id" interface="zxdg_toplevel_v6"/>
+      <arg name="id" type="new_id" interface="xdg_toplevel"/>
     </request>
 
     <request name="get_popup">
       <description summary="assign the xdg_popup surface role">
-	This creates an xdg_popup object for the given xdg_surface and gives the
-	associated wl_surface the xdg_popup role.
+	This creates an xdg_popup object for the given xdg_surface and gives
+	the associated wl_surface the xdg_popup role.
+
+	If null is passed as a parent, a parent surface must be specified using
+	some other protocol, before committing the initial state.
 
 	See the documentation of xdg_popup for more details about what an
 	xdg_popup is and how it is used.
       </description>
-      <arg name="id" type="new_id" interface="zxdg_popup_v6"/>
-      <arg name="parent" type="object" interface="zxdg_surface_v6"/>
-      <arg name="positioner" type="object" interface="zxdg_positioner_v6"/>
+      <arg name="id" type="new_id" interface="xdg_popup"/>
+      <arg name="parent" type="object" interface="xdg_surface" allow-null="true"/>
+      <arg name="positioner" type="object" interface="xdg_positioner"/>
     </request>
 
     <request name="set_window_geometry">
@@ -442,6 +497,11 @@
 	The window geometry is double buffered, and will be applied at the
 	time wl_surface.commit of the corresponding wl_surface is called.
 
+	When maintaining a position, the compositor should treat the (x, y)
+	coordinate of the window geometry as the top left corner of the window.
+	A client changing the (x, y) window geometry coordinate should in
+	general not alter the position of the window.
+
 	Once the window geometry of the surface is set, it is not possible to
 	unset it, and it will remain the same until set_window_geometry is
 	called again, even if a new subsurface or buffer is attached.
@@ -511,36 +571,57 @@
       </description>
       <arg name="serial" type="uint" summary="serial of the configure event"/>
     </event>
+
   </interface>
 
-  <interface name="zxdg_toplevel_v6" version="1">
+  <interface name="xdg_toplevel" version="3">
     <description summary="toplevel surface">
       This interface defines an xdg_surface role which allows a surface to,
       among other things, set window-like properties such as maximize,
       fullscreen, and minimize, set application-specific metadata like title and
       id, and well as trigger user interactive operations such as interactive
       resize and move.
+
+      Unmapping an xdg_toplevel means that the surface cannot be shown
+      by the compositor until it is explicitly mapped again.
+      All active operations (e.g., move, resize) are canceled and all
+      attributes (e.g. title, state, stacking, ...) are discarded for
+      an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
+      the state it had right after xdg_surface.get_toplevel. The client
+      can re-map the toplevel by perfoming a commit without any buffer
+      attached, waiting for a configure event and handling it as usual (see
+      xdg_surface description).
+
+      Attaching a null buffer to a toplevel unmaps the surface.
     </description>
 
     <request name="destroy" type="destructor">
       <description summary="destroy the xdg_toplevel">
-	Unmap and destroy the window. The window will be effectively
-	hidden from the user's point of view, and all state like
-	maximization, fullscreen, and so on, will be lost.
+	This request destroys the role surface and unmaps the surface;
+	see "Unmapping" behavior in interface section for details.
       </description>
     </request>
 
     <request name="set_parent">
       <description summary="set the parent of this surface">
-	Set the "parent" of this surface. This window should be stacked
-	above a parent. The parent surface must be mapped as long as this
-	surface is mapped.
+	Set the "parent" of this surface. This surface should be stacked
+	above the parent surface and all other ancestor surfaces.
 
 	Parent windows should be set on dialogs, toolboxes, or other
 	"auxiliary" surfaces, so that the parent is raised when the dialog
 	is raised.
+
+	Setting a null parent for a child window removes any parent-child
+	relationship for the child. Setting a null parent for a window which
+	currently has no parent is a no-op.
+
+	If the parent is unmapped then its children are managed as
+	though the parent of the now-unmapped parent has become the
+	parent of this surface. If no parent exists for the now-unmapped
+	parent then the children are managed as though they have no
+	parent surface.
       </description>
-      <arg name="parent" type="object" interface="zxdg_toplevel_v6" allow-null="true"/>
+      <arg name="parent" type="object" interface="xdg_toplevel" allow-null="true"/>
     </request>
 
     <request name="set_title">
@@ -573,6 +654,9 @@
 	For example, "org.freedesktop.FooViewer" where the .desktop file is
 	"org.freedesktop.FooViewer.desktop".
 
+	Like other properties, a set_app_id request can be sent after the
+	xdg_toplevel has been mapped to update the property.
+
 	See the desktop-entry specification [0] for more details on
 	application identifiers and how they relate to well-known D-Bus
 	names and .desktop files.
@@ -676,7 +760,7 @@
       </description>
       <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat of the user event"/>
       <arg name="serial" type="uint" summary="the serial of the user event"/>
-      <arg name="edges" type="uint" summary="which edge or corner is being dragged"/>
+      <arg name="edges" type="uint" enum="resize_edge" summary="which edge or corner is being dragged"/>
     </request>
 
     <enum name="state">
@@ -693,12 +777,18 @@
 	<description summary="the surface is maximized">
 	  The surface is maximized. The window geometry specified in the configure
 	  event must be obeyed by the client.
+
+	  The client should draw without shadow or other
+	  decoration outside of the window geometry.
 	</description>
       </entry>
       <entry name="fullscreen" value="2" summary="the surface is fullscreen">
 	<description summary="the surface is fullscreen">
-	  The surface is fullscreen. The window geometry specified in the configure
-	  event must be obeyed by the client.
+	  The surface is fullscreen. The window geometry specified in the
+	  configure event is a maximum; the client cannot resize beyond it. For
+	  a surface to cover the whole fullscreened area, the geometry
+	  dimensions must be obeyed by the client. For more details, see
+	  xdg_toplevel.set_fullscreen.
 	</description>
       </entry>
       <entry name="resizing" value="3" summary="the surface is being resized">
@@ -716,6 +806,30 @@
 	  keyboard or pointer focus.
 	</description>
       </entry>
+      <entry name="tiled_left" value="5" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the left edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
+      <entry name="tiled_right" value="6" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the right edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
+      <entry name="tiled_top" value="7" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the top edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
+      <entry name="tiled_bottom" value="8" since="2">
+	<description summary="the surface is tiled">
+	  The window is currently in a tiled layout and the bottom edge is
+	  considered to be adjacent to another part of the tiling grid.
+	</description>
+      </entry>
     </enum>
 
     <request name="set_max_size">
@@ -805,12 +919,11 @@
 	Maximize the surface.
 
 	After requesting that the surface should be maximized, the compositor
-	will respond by emitting a configure event with the "maximized" state
-	and the required window geometry. The client should then update its
-	content, drawing it in a maximized state, i.e. without shadow or other
-	decoration outside of the window geometry. The client must also
-	acknowledge the configure when committing the new content (see
-	ack_configure).
+	will respond by emitting a configure event. Whether this configure
+	actually sets the window maximized is subject to compositor policies.
+	The client must then update its content, drawing in the configured
+	state. The client must also acknowledge the configure when committing
+	the new content (see ack_configure).
 
 	It is up to the compositor to decide how and where to maximize the
 	surface, for example which output and what region of the screen should
@@ -818,6 +931,10 @@
 
 	If the surface was already maximized, the compositor will still emit
 	a configure event with the "maximized" state.
+
+	If the surface is in a fullscreen state, this request has no direct
+	effect. It may alter the state the surface is returned to when
+	unmaximized unless overridden by the compositor.
       </description>
     </request>
 
@@ -826,13 +943,13 @@
 	Unmaximize the surface.
 
 	After requesting that the surface should be unmaximized, the compositor
-	will respond by emitting a configure event without the "maximized"
-	state. If available, the compositor will include the window geometry
-	dimensions the window had prior to being maximized in the configure
-	request. The client must then update its content, drawing it in a
-	regular state, i.e. potentially with shadow, etc. The client must also
-	acknowledge the configure when committing the new content (see
-	ack_configure).
+	will respond by emitting a configure event. Whether this actually
+	un-maximizes the window is subject to compositor policies.
+	If available and applicable, the compositor will include the window
+	geometry dimensions the window had prior to being maximized in the
+	configure event. The client must then update its content, drawing it in
+	the configured state. The client must also acknowledge the configure
+	when committing the new content (see ack_configure).
 
 	It is up to the compositor to position the surface after it was
 	unmaximized; usually the position the surface had before maximizing, if
@@ -840,24 +957,63 @@
 
 	If the surface was already not maximized, the compositor will still
 	emit a configure event without the "maximized" state.
+
+	If the surface is in a fullscreen state, this request has no direct
+	effect. It may alter the state the surface is returned to when
+	unmaximized unless overridden by the compositor.
       </description>
     </request>
 
     <request name="set_fullscreen">
-      <description summary="set the window as fullscreen on a monitor">
+      <description summary="set the window as fullscreen on an output">
 	Make the surface fullscreen.
 
-	You can specify an output that you would prefer to be fullscreen.
-	If this value is NULL, it's up to the compositor to choose which
-	display will be used to map this surface.
+	After requesting that the surface should be fullscreened, the
+	compositor will respond by emitting a configure event. Whether the
+	client is actually put into a fullscreen state is subject to compositor
+	policies. The client must also acknowledge the configure when
+	committing the new content (see ack_configure).
+
+	The output passed by the request indicates the client's preference as
+	to which display it should be set fullscreen on. If this value is NULL,
+	it's up to the compositor to choose which display will be used to map
+	this surface.
 
 	If the surface doesn't cover the whole output, the compositor will
 	position the surface in the center of the output and compensate with
-	black borders filling the rest of the output.
+	with border fill covering the rest of the output. The content of the
+	border fill is undefined, but should be assumed to be in some way that
+	attempts to blend into the surrounding area (e.g. solid black).
+
+	If the fullscreened surface is not opaque, the compositor must make
+	sure that other screen content not part of the same surface tree (made
+	up of subsurfaces, popups or similarly coupled surfaces) are not
+	visible below the fullscreened surface.
       </description>
       <arg name="output" type="object" interface="wl_output" allow-null="true"/>
     </request>
-    <request name="unset_fullscreen" />
+
+    <request name="unset_fullscreen">
+      <description summary="unset the window as fullscreen">
+	Make the surface no longer fullscreen.
+
+	After requesting that the surface should be unfullscreened, the
+	compositor will respond by emitting a configure event.
+	Whether this actually removes the fullscreen state of the client is
+	subject to compositor policies.
+
+	Making a surface unfullscreen sets states for the surface based on the following:
+	* the state(s) it may have had before becoming fullscreen
+	* any state(s) decided by the compositor
+	* any state(s) requested by the client while the surface was fullscreen
+
+	The compositor may include the previous window geometry dimensions in
+	the configure event, if applicable.
+
+	The client must also acknowledge the configure when committing the new
+	content (see ack_configure).
+      </description>
+    </request>
 
     <request name="set_minimized">
       <description summary="set the window as minimized">
@@ -913,7 +1069,7 @@
     </event>
   </interface>
 
-  <interface name="zxdg_popup_v6" version="1">
+  <interface name="xdg_popup" version="3">
     <description summary="short-lived, popup surfaces for menus">
       A popup surface is a short-lived, temporary surface. It can be used to
       implement for example menus, popovers, tooltips and other similar user
@@ -931,21 +1087,12 @@
       surface of their own is clicked should dismiss the popup using the destroy
       request.
 
-      The parent surface must have either the xdg_toplevel or xdg_popup surface
-      role.
-
       A newly created xdg_popup will be stacked on top of all previously created
       xdg_popup surfaces associated with the same xdg_toplevel.
 
       The parent of an xdg_popup must be mapped (see the xdg_surface
       description) before the xdg_popup itself.
 
-      The x and y arguments passed when creating the popup object specify
-      where the top left of the popup should be placed, relative to the
-      local surface coordinates of the parent surface. See
-      xdg_surface.get_popup. An xdg_popup must intersect with or be at least
-      partially adjacent to its parent surface.
-
       The client must call wl_surface.commit on the corresponding wl_surface
       for the xdg_popup state to take effect.
     </description>
@@ -1023,6 +1170,11 @@
 	The x and y arguments represent the position the popup was placed at
 	given the xdg_positioner rule, relative to the upper left corner of the
 	window geometry of the parent surface.
+
+	For version 2 or older, the configure event for an xdg_popup is only
+	ever sent once for the initial configuration. Starting with version 3,
+	it may be sent again if the popup is setup with an xdg_positioner with
+	set_reactive requested, or in response to xdg_popup.reposition requests.
       </description>
       <arg name="x" type="int"
 	   summary="x position relative to parent surface window geometry"/>
@@ -1040,5 +1192,58 @@
       </description>
     </event>
 
+    <!-- Version 3 additions -->
+
+    <request name="reposition" since="3">
+      <description summary="recalculate the popup's location">
+	Reposition an already-mapped popup. The popup will be placed given the
+	details in the passed xdg_positioner object, and a
+	xdg_popup.repositioned followed by xdg_popup.configure and
+	xdg_surface.configure will be emitted in response. Any parameters set
+	by the previous positioner will be discarded.
+
+	The passed token will be sent in the corresponding
+	xdg_popup.repositioned event. The new popup position will not take
+	effect until the corresponding configure event is acknowledged by the
+	client. See xdg_popup.repositioned for details. The token itself is
+	opaque, and has no other special meaning.
+
+	If multiple reposition requests are sent, the compositor may skip all
+	but the last one.
+
+	If the popup is repositioned in response to a configure event for its
+	parent, the client should send an xdg_positioner.set_parent_configure
+	and possibly a xdg_positioner.set_parent_size request to allow the
+	compositor to properly constrain the popup.
+
+	If the popup is repositioned together with a parent that is being
+	resized, but not in response to a configure event, the client should
+	send a xdg_positioner.set_parent_size request.
+      </description>
+      <arg name="positioner" type="object" interface="xdg_positioner"/>
+      <arg name="token" type="uint" summary="reposition request token"/>
+    </request>
+
+    <event name="repositioned" since="3">
+      <description summary="signal the completion of a repositioned request">
+	The repositioned event is sent as part of a popup configuration
+	sequence, together with xdg_popup.configure and lastly
+	xdg_surface.configure to notify the completion of a reposition request.
+
+	The repositioned event is to notify about the completion of a
+	xdg_popup.reposition request. The token argument is the token passed
+	in the xdg_popup.reposition request.
+
+	Immediately after this event is emitted, xdg_popup.configure and
+	xdg_surface.configure will be sent with the updated size and position,
+	as well as a new configure serial.
+
+	The client should optionally update the content of the popup, but must
+	acknowledge the new popup configuration for the new position to take
+	effect. See xdg_surface.ack_configure for details.
+      </description>
+      <arg name="token" type="uint" summary="reposition request token"/>
+    </event>
+
   </interface>
 </protocol>
diff --git a/vm_tools/sommelier/sommelier-xdg-shell.cc b/vm_tools/sommelier/sommelier-xdg-shell.cc
index 91744a67e3..45b8eeb93e 100644
--- a/vm_tools/sommelier/sommelier-xdg-shell.cc
+++ b/vm_tools/sommelier/sommelier-xdg-shell.cc
@@ -7,37 +7,37 @@
 #include <assert.h>
 #include <stdlib.h>
 
-#include "xdg-shell-unstable-v6-client-protocol.h"  // NOLINT(build/include_directory)
-#include "xdg-shell-unstable-v6-server-protocol.h"  // NOLINT(build/include_directory)
+#include "xdg-shell-client-protocol.h"  // NOLINT(build/include_directory)
+#include "xdg-shell-server-protocol.h"  // NOLINT(build/include_directory)
 
 struct sl_host_xdg_shell {
   struct sl_context* ctx;
   struct wl_resource* resource;
-  struct zxdg_shell_v6* proxy;
+  struct xdg_wm_base* proxy;
 };
 
 struct sl_host_xdg_surface {
   struct sl_context* ctx;
   struct wl_resource* resource;
-  struct zxdg_surface_v6* proxy;
+  struct xdg_surface* proxy;
 };
 
 struct sl_host_xdg_toplevel {
   struct sl_context* ctx;
   struct wl_resource* resource;
-  struct zxdg_toplevel_v6* proxy;
+  struct xdg_toplevel* proxy;
 };
 
 struct sl_host_xdg_popup {
   struct sl_context* ctx;
   struct wl_resource* resource;
-  struct zxdg_popup_v6* proxy;
+  struct xdg_popup* proxy;
 };
 
 struct sl_host_xdg_positioner {
   struct sl_context* ctx;
   struct wl_resource* resource;
-  struct zxdg_positioner_v6* proxy;
+  struct xdg_positioner* proxy;
 };
 
 static void sl_xdg_positioner_destroy(struct wl_client* client,
@@ -53,7 +53,7 @@ static void sl_xdg_positioner_set_size(struct wl_client* client,
       static_cast<sl_host_xdg_positioner*>(wl_resource_get_user_data(resource));
   double scale = host->ctx->scale;
 
-  zxdg_positioner_v6_set_size(host->proxy, width / scale, height / scale);
+  xdg_positioner_set_size(host->proxy, width / scale, height / scale);
 }
 
 static void sl_xdg_positioner_set_anchor_rect(struct wl_client* client,
@@ -72,7 +72,7 @@ static void sl_xdg_positioner_set_anchor_rect(struct wl_client* client,
   x2 = (x + width) / scale;
   y2 = (y + height) / scale;
 
-  zxdg_positioner_v6_set_anchor_rect(host->proxy, x1, y1, x2 - x1, y2 - y1);
+  xdg_positioner_set_anchor_rect(host->proxy, x1, y1, x2 - x1, y2 - y1);
 }
 
 static void sl_xdg_positioner_set_anchor(struct wl_client* client,
@@ -81,7 +81,7 @@ static void sl_xdg_positioner_set_anchor(struct wl_client* client,
   struct sl_host_xdg_positioner* host =
       static_cast<sl_host_xdg_positioner*>(wl_resource_get_user_data(resource));
 
-  zxdg_positioner_v6_set_anchor(host->proxy, anchor);
+  xdg_positioner_set_anchor(host->proxy, anchor);
 }
 
 static void sl_xdg_positioner_set_gravity(struct wl_client* client,
@@ -90,7 +90,7 @@ static void sl_xdg_positioner_set_gravity(struct wl_client* client,
   struct sl_host_xdg_positioner* host =
       static_cast<sl_host_xdg_positioner*>(wl_resource_get_user_data(resource));
 
-  zxdg_positioner_v6_set_gravity(host->proxy, gravity);
+  xdg_positioner_set_gravity(host->proxy, gravity);
 }
 
 static void sl_xdg_positioner_set_constraint_adjustment(
@@ -100,8 +100,7 @@ static void sl_xdg_positioner_set_constraint_adjustment(
   struct sl_host_xdg_positioner* host =
       static_cast<sl_host_xdg_positioner*>(wl_resource_get_user_data(resource));
 
-  zxdg_positioner_v6_set_constraint_adjustment(host->proxy,
-                                               constraint_adjustment);
+  xdg_positioner_set_constraint_adjustment(host->proxy, constraint_adjustment);
 }  // NOLINT(whitespace/indent)
 
 static void sl_xdg_positioner_set_offset(struct wl_client* client,
@@ -112,24 +111,23 @@ static void sl_xdg_positioner_set_offset(struct wl_client* client,
       static_cast<sl_host_xdg_positioner*>(wl_resource_get_user_data(resource));
   double scale = host->ctx->scale;
 
-  zxdg_positioner_v6_set_offset(host->proxy, x / scale, y / scale);
+  xdg_positioner_set_offset(host->proxy, x / scale, y / scale);
 }
 
-static const struct zxdg_positioner_v6_interface
-    sl_xdg_positioner_implementation = {
-        sl_xdg_positioner_destroy,
-        sl_xdg_positioner_set_size,
-        sl_xdg_positioner_set_anchor_rect,
-        sl_xdg_positioner_set_anchor,
-        sl_xdg_positioner_set_gravity,
-        sl_xdg_positioner_set_constraint_adjustment,
-        sl_xdg_positioner_set_offset};
+static const struct xdg_positioner_interface sl_xdg_positioner_implementation =
+    {sl_xdg_positioner_destroy,
+     sl_xdg_positioner_set_size,
+     sl_xdg_positioner_set_anchor_rect,
+     sl_xdg_positioner_set_anchor,
+     sl_xdg_positioner_set_gravity,
+     sl_xdg_positioner_set_constraint_adjustment,
+     sl_xdg_positioner_set_offset};
 
 static void sl_destroy_host_xdg_positioner(struct wl_resource* resource) {
   struct sl_host_xdg_positioner* host =
       static_cast<sl_host_xdg_positioner*>(wl_resource_get_user_data(resource));
 
-  zxdg_positioner_v6_destroy(host->proxy);
+  xdg_positioner_destroy(host->proxy);
   wl_resource_set_user_data(resource, NULL);
   free(host);
 }
@@ -148,20 +146,20 @@ static void sl_xdg_popup_grab(struct wl_client* client,
   struct sl_host_seat* host_seat =
       static_cast<sl_host_seat*>(wl_resource_get_user_data(seat_resource));
 
-  zxdg_popup_v6_grab(host->proxy, host_seat->proxy, serial);
+  xdg_popup_grab(host->proxy, host_seat->proxy, serial);
 }  // NOLINT(whitespace/indent)
 
-static const struct zxdg_popup_v6_interface sl_xdg_popup_implementation = {
+static const struct xdg_popup_interface sl_xdg_popup_implementation = {
     sl_xdg_popup_destroy, sl_xdg_popup_grab};
 
 static void sl_xdg_popup_configure(void* data,
-                                   struct zxdg_popup_v6* xdg_popup,
+                                   struct xdg_popup* xdg_popup,
                                    int32_t x,
                                    int32_t y,
                                    int32_t width,
                                    int32_t height) {
   struct sl_host_xdg_popup* host =
-      static_cast<sl_host_xdg_popup*>(zxdg_popup_v6_get_user_data(xdg_popup));
+      static_cast<sl_host_xdg_popup*>(xdg_popup_get_user_data(xdg_popup));
   double scale = host->ctx->scale;
   int32_t x1, y1, x2, y2;
 
@@ -170,25 +168,24 @@ static void sl_xdg_popup_configure(void* data,
   x2 = (x + width) * scale;
   y2 = (y + height) * scale;
 
-  zxdg_popup_v6_send_configure(host->resource, x1, y1, x2 - x1, y2 - y1);
+  xdg_popup_send_configure(host->resource, x1, y1, x2 - x1, y2 - y1);
 }
 
-static void sl_xdg_popup_popup_done(void* data,
-                                    struct zxdg_popup_v6* xdg_popup) {
+static void sl_xdg_popup_popup_done(void* data, struct xdg_popup* xdg_popup) {
   struct sl_host_xdg_popup* host =
-      static_cast<sl_host_xdg_popup*>(zxdg_popup_v6_get_user_data(xdg_popup));
+      static_cast<sl_host_xdg_popup*>(xdg_popup_get_user_data(xdg_popup));
 
-  zxdg_popup_v6_send_popup_done(host->resource);
+  xdg_popup_send_popup_done(host->resource);
 }
 
-static const struct zxdg_popup_v6_listener sl_xdg_popup_listener = {
+static const struct xdg_popup_listener sl_xdg_popup_listener = {
     sl_xdg_popup_configure, sl_xdg_popup_popup_done};
 
 static void sl_destroy_host_xdg_popup(struct wl_resource* resource) {
   struct sl_host_xdg_popup* host =
       static_cast<sl_host_xdg_popup*>(wl_resource_get_user_data(resource));
 
-  zxdg_popup_v6_destroy(host->proxy);
+  xdg_popup_destroy(host->proxy);
   wl_resource_set_user_data(resource, NULL);
   free(host);
 }
@@ -208,8 +205,7 @@ static void sl_xdg_toplevel_set_parent(struct wl_client* client,
                             wl_resource_get_user_data(parent_resource))
                       : NULL;
 
-  zxdg_toplevel_v6_set_parent(host->proxy,
-                              host_parent ? host_parent->proxy : NULL);
+  xdg_toplevel_set_parent(host->proxy, host_parent ? host_parent->proxy : NULL);
 }
 
 static void sl_xdg_toplevel_set_title(struct wl_client* client,
@@ -218,7 +214,7 @@ static void sl_xdg_toplevel_set_title(struct wl_client* client,
   struct sl_host_xdg_toplevel* host =
       static_cast<sl_host_xdg_toplevel*>(wl_resource_get_user_data(resource));
 
-  zxdg_toplevel_v6_set_title(host->proxy, title);
+  xdg_toplevel_set_title(host->proxy, title);
 }
 
 static void sl_xdg_toplevel_set_app_id(struct wl_client* client,
@@ -227,7 +223,7 @@ static void sl_xdg_toplevel_set_app_id(struct wl_client* client,
   struct sl_host_xdg_toplevel* host =
       static_cast<sl_host_xdg_toplevel*>(wl_resource_get_user_data(resource));
 
-  zxdg_toplevel_v6_set_app_id(host->proxy, app_id);
+  xdg_toplevel_set_app_id(host->proxy, app_id);
 }
 
 static void sl_xdg_toplevel_show_window_menu(struct wl_client* client,
@@ -243,7 +239,7 @@ static void sl_xdg_toplevel_show_window_menu(struct wl_client* client,
           ? static_cast<sl_host_seat*>(wl_resource_get_user_data(seat_resource))
           : NULL;
 
-  zxdg_toplevel_v6_show_window_menu(
+  xdg_toplevel_show_window_menu(
       host->proxy, host_seat ? host_seat->proxy : NULL, serial, x, y);
 }  // NOLINT(whitespace/indent)
 
@@ -258,8 +254,7 @@ static void sl_xdg_toplevel_move(struct wl_client* client,
           ? static_cast<sl_host_seat*>(wl_resource_get_user_data(seat_resource))
           : NULL;
 
-  zxdg_toplevel_v6_move(host->proxy, host_seat ? host_seat->proxy : NULL,
-                        serial);
+  xdg_toplevel_move(host->proxy, host_seat ? host_seat->proxy : NULL, serial);
 }  // NOLINT(whitespace/indent)
 
 static void sl_xdg_toplevel_resize(struct wl_client* client,
@@ -274,8 +269,8 @@ static void sl_xdg_toplevel_resize(struct wl_client* client,
           ? static_cast<sl_host_seat*>(wl_resource_get_user_data(seat_resource))
           : NULL;
 
-  zxdg_toplevel_v6_resize(host->proxy, host_seat ? host_seat->proxy : NULL,
-                          serial, edges);
+  xdg_toplevel_resize(host->proxy, host_seat ? host_seat->proxy : NULL, serial,
+                      edges);
 }  // NOLINT(whitespace/indent)
 
 static void sl_xdg_toplevel_set_max_size(struct wl_client* client,
@@ -285,7 +280,7 @@ static void sl_xdg_toplevel_set_max_size(struct wl_client* client,
   struct sl_host_xdg_toplevel* host =
       static_cast<sl_host_xdg_toplevel*>(wl_resource_get_user_data(resource));
 
-  zxdg_toplevel_v6_set_max_size(host->proxy, width, height);
+  xdg_toplevel_set_max_size(host->proxy, width, height);
 }
 
 static void sl_xdg_toplevel_set_min_size(struct wl_client* client,
@@ -295,7 +290,7 @@ static void sl_xdg_toplevel_set_min_size(struct wl_client* client,
   struct sl_host_xdg_toplevel* host =
       static_cast<sl_host_xdg_toplevel*>(wl_resource_get_user_data(resource));
 
-  zxdg_toplevel_v6_set_min_size(host->proxy, width, height);
+  xdg_toplevel_set_min_size(host->proxy, width, height);
 }
 
 static void sl_xdg_toplevel_set_maximized(struct wl_client* client,
@@ -303,7 +298,7 @@ static void sl_xdg_toplevel_set_maximized(struct wl_client* client,
   struct sl_host_xdg_toplevel* host =
       static_cast<sl_host_xdg_toplevel*>(wl_resource_get_user_data(resource));
 
-  zxdg_toplevel_v6_set_maximized(host->proxy);
+  xdg_toplevel_set_maximized(host->proxy);
 }
 
 static void sl_xdg_toplevel_unset_maximized(struct wl_client* client,
@@ -311,7 +306,7 @@ static void sl_xdg_toplevel_unset_maximized(struct wl_client* client,
   struct sl_host_xdg_toplevel* host =
       static_cast<sl_host_xdg_toplevel*>(wl_resource_get_user_data(resource));
 
-  zxdg_toplevel_v6_unset_maximized(host->proxy);
+  xdg_toplevel_unset_maximized(host->proxy);
 }
 
 static void sl_xdg_toplevel_set_fullscreen(
@@ -325,8 +320,8 @@ static void sl_xdg_toplevel_set_fullscreen(
                             wl_resource_get_user_data(output_resource))
                       : NULL;
 
-  zxdg_toplevel_v6_set_fullscreen(host->proxy,
-                                  host_output ? host_output->proxy : NULL);
+  xdg_toplevel_set_fullscreen(host->proxy,
+                              host_output ? host_output->proxy : NULL);
 }  // NOLINT(whitespace/indent)
 
 static void sl_xdg_toplevel_unset_fullscreen(struct wl_client* client,
@@ -334,7 +329,7 @@ static void sl_xdg_toplevel_unset_fullscreen(struct wl_client* client,
   struct sl_host_xdg_toplevel* host =
       static_cast<sl_host_xdg_toplevel*>(wl_resource_get_user_data(resource));
 
-  zxdg_toplevel_v6_unset_fullscreen(host->proxy);
+  xdg_toplevel_unset_fullscreen(host->proxy);
 }
 
 static void sl_xdg_toplevel_set_minimized(struct wl_client* client,
@@ -342,47 +337,47 @@ static void sl_xdg_toplevel_set_minimized(struct wl_client* client,
   struct sl_host_xdg_toplevel* host =
       static_cast<sl_host_xdg_toplevel*>(wl_resource_get_user_data(resource));
 
-  zxdg_toplevel_v6_set_minimized(host->proxy);
+  xdg_toplevel_set_minimized(host->proxy);
 }
 
-static const struct zxdg_toplevel_v6_interface sl_xdg_toplevel_implementation =
-    {sl_xdg_toplevel_destroy,          sl_xdg_toplevel_set_parent,
-     sl_xdg_toplevel_set_title,        sl_xdg_toplevel_set_app_id,
-     sl_xdg_toplevel_show_window_menu, sl_xdg_toplevel_move,
-     sl_xdg_toplevel_resize,           sl_xdg_toplevel_set_max_size,
-     sl_xdg_toplevel_set_min_size,     sl_xdg_toplevel_set_maximized,
-     sl_xdg_toplevel_unset_maximized,  sl_xdg_toplevel_set_fullscreen,
-     sl_xdg_toplevel_unset_fullscreen, sl_xdg_toplevel_set_minimized};
+static const struct xdg_toplevel_interface sl_xdg_toplevel_implementation = {
+    sl_xdg_toplevel_destroy,          sl_xdg_toplevel_set_parent,
+    sl_xdg_toplevel_set_title,        sl_xdg_toplevel_set_app_id,
+    sl_xdg_toplevel_show_window_menu, sl_xdg_toplevel_move,
+    sl_xdg_toplevel_resize,           sl_xdg_toplevel_set_max_size,
+    sl_xdg_toplevel_set_min_size,     sl_xdg_toplevel_set_maximized,
+    sl_xdg_toplevel_unset_maximized,  sl_xdg_toplevel_set_fullscreen,
+    sl_xdg_toplevel_unset_fullscreen, sl_xdg_toplevel_set_minimized};
 
 static void sl_xdg_toplevel_configure(void* data,
-                                      struct zxdg_toplevel_v6* xdg_toplevel,
+                                      struct xdg_toplevel* xdg_toplevel,
                                       int32_t width,
                                       int32_t height,
                                       struct wl_array* states) {
   struct sl_host_xdg_toplevel* host = static_cast<sl_host_xdg_toplevel*>(
-      zxdg_toplevel_v6_get_user_data(xdg_toplevel));
+      xdg_toplevel_get_user_data(xdg_toplevel));
   double scale = host->ctx->scale;
 
-  zxdg_toplevel_v6_send_configure(host->resource, width * scale, height * scale,
-                                  states);
+  xdg_toplevel_send_configure(host->resource, width * scale, height * scale,
+                              states);
 }
 
 static void sl_xdg_toplevel_close(void* data,
-                                  struct zxdg_toplevel_v6* xdg_toplevel) {
+                                  struct xdg_toplevel* xdg_toplevel) {
   struct sl_host_xdg_toplevel* host = static_cast<sl_host_xdg_toplevel*>(
-      zxdg_toplevel_v6_get_user_data(xdg_toplevel));
+      xdg_toplevel_get_user_data(xdg_toplevel));
 
-  zxdg_toplevel_v6_send_close(host->resource);
+  xdg_toplevel_send_close(host->resource);
 }
 
-static const struct zxdg_toplevel_v6_listener sl_xdg_toplevel_listener = {
+static const struct xdg_toplevel_listener sl_xdg_toplevel_listener = {
     sl_xdg_toplevel_configure, sl_xdg_toplevel_close};
 
 static void sl_destroy_host_xdg_toplevel(struct wl_resource* resource) {
   struct sl_host_xdg_toplevel* host =
       static_cast<sl_host_xdg_toplevel*>(wl_resource_get_user_data(resource));
 
-  zxdg_toplevel_v6_destroy(host->proxy);
+  xdg_toplevel_destroy(host->proxy);
   wl_resource_set_user_data(resource, NULL);
   free(host);
 }
@@ -403,14 +398,14 @@ static void sl_xdg_surface_get_toplevel(struct wl_client* client,
 
   host_xdg_toplevel->ctx = host->ctx;
   host_xdg_toplevel->resource =
-      wl_resource_create(client, &zxdg_toplevel_v6_interface, 1, id);
+      wl_resource_create(client, &xdg_toplevel_interface, 1, id);
   wl_resource_set_implementation(
       host_xdg_toplevel->resource, &sl_xdg_toplevel_implementation,
       host_xdg_toplevel, sl_destroy_host_xdg_toplevel);
-  host_xdg_toplevel->proxy = zxdg_surface_v6_get_toplevel(host->proxy);
-  zxdg_toplevel_v6_set_user_data(host_xdg_toplevel->proxy, host_xdg_toplevel);
-  zxdg_toplevel_v6_add_listener(host_xdg_toplevel->proxy,
-                                &sl_xdg_toplevel_listener, host_xdg_toplevel);
+  host_xdg_toplevel->proxy = xdg_surface_get_toplevel(host->proxy);
+  xdg_toplevel_set_user_data(host_xdg_toplevel->proxy, host_xdg_toplevel);
+  xdg_toplevel_add_listener(host_xdg_toplevel->proxy, &sl_xdg_toplevel_listener,
+                            host_xdg_toplevel);
 }
 
 static void sl_xdg_surface_get_popup(struct wl_client* client,
@@ -421,7 +416,7 @@ static void sl_xdg_surface_get_popup(struct wl_client* client,
   struct sl_host_xdg_surface* host =
       static_cast<sl_host_xdg_surface*>(wl_resource_get_user_data(resource));
   struct sl_host_xdg_surface* host_parent = static_cast<sl_host_xdg_surface*>(
-      wl_resource_get_user_data(parent_resource));
+      parent_resource ? wl_resource_get_user_data(parent_resource) : NULL);
   struct sl_host_xdg_positioner* host_positioner =
       static_cast<sl_host_xdg_positioner*>(
           wl_resource_get_user_data(positioner_resource));
@@ -431,15 +426,16 @@ static void sl_xdg_surface_get_popup(struct wl_client* client,
 
   host_xdg_popup->ctx = host->ctx;
   host_xdg_popup->resource =
-      wl_resource_create(client, &zxdg_popup_v6_interface, 1, id);
+      wl_resource_create(client, &xdg_popup_interface, 1, id);
   wl_resource_set_implementation(host_xdg_popup->resource,
                                  &sl_xdg_popup_implementation, host_xdg_popup,
                                  sl_destroy_host_xdg_popup);
-  host_xdg_popup->proxy = zxdg_surface_v6_get_popup(
-      host->proxy, host_parent->proxy, host_positioner->proxy);
-  zxdg_popup_v6_set_user_data(host_xdg_popup->proxy, host_xdg_popup);
-  zxdg_popup_v6_add_listener(host_xdg_popup->proxy, &sl_xdg_popup_listener,
-                             host_xdg_popup);
+  host_xdg_popup->proxy = xdg_surface_get_popup(
+      host->proxy, host_parent ? host_parent->proxy : NULL,
+      host_positioner->proxy);
+  xdg_popup_set_user_data(host_xdg_popup->proxy, host_xdg_popup);
+  xdg_popup_add_listener(host_xdg_popup->proxy, &sl_xdg_popup_listener,
+                         host_xdg_popup);
 }  // NOLINT(whitespace/indent)
 
 static void sl_xdg_surface_set_window_geometry(struct wl_client* client,
@@ -458,7 +454,7 @@ static void sl_xdg_surface_set_window_geometry(struct wl_client* client,
   x2 = (x + width) / scale;
   y2 = (y + height) / scale;
 
-  zxdg_surface_v6_set_window_geometry(host->proxy, x1, y1, x2 - x1, y2 - y1);
+  xdg_surface_set_window_geometry(host->proxy, x1, y1, x2 - x1, y2 - y1);
 }
 
 static void sl_xdg_surface_ack_configure(struct wl_client* client,
@@ -467,31 +463,31 @@ static void sl_xdg_surface_ack_configure(struct wl_client* client,
   struct sl_host_xdg_surface* host =
       static_cast<sl_host_xdg_surface*>(wl_resource_get_user_data(resource));
 
-  zxdg_surface_v6_ack_configure(host->proxy, serial);
+  xdg_surface_ack_configure(host->proxy, serial);
 }
 
-static const struct zxdg_surface_v6_interface sl_xdg_surface_implementation = {
+static const struct xdg_surface_interface sl_xdg_surface_implementation = {
     sl_xdg_surface_destroy, sl_xdg_surface_get_toplevel,
     sl_xdg_surface_get_popup, sl_xdg_surface_set_window_geometry,
     sl_xdg_surface_ack_configure};
 
 static void sl_xdg_surface_configure(void* data,
-                                     struct zxdg_surface_v6* xdg_surface,
+                                     struct xdg_surface* xdg_surface,
                                      uint32_t serial) {
   struct sl_host_xdg_surface* host = static_cast<sl_host_xdg_surface*>(
-      zxdg_surface_v6_get_user_data(xdg_surface));
+      xdg_surface_get_user_data(xdg_surface));
 
-  zxdg_surface_v6_send_configure(host->resource, serial);
+  xdg_surface_send_configure(host->resource, serial);
 }
 
-static const struct zxdg_surface_v6_listener sl_xdg_surface_listener = {
+static const struct xdg_surface_listener sl_xdg_surface_listener = {
     sl_xdg_surface_configure};
 
 static void sl_destroy_host_xdg_surface(struct wl_resource* resource) {
   struct sl_host_xdg_surface* host =
       static_cast<sl_host_xdg_surface*>(wl_resource_get_user_data(resource));
 
-  zxdg_surface_v6_destroy(host->proxy);
+  xdg_surface_destroy(host->proxy);
   wl_resource_set_user_data(resource, NULL);
   free(host);
 }
@@ -513,13 +509,12 @@ static void sl_xdg_shell_create_positioner(struct wl_client* client,
 
   host_xdg_positioner->ctx = host->ctx;
   host_xdg_positioner->resource =
-      wl_resource_create(client, &zxdg_positioner_v6_interface, 1, id);
+      wl_resource_create(client, &xdg_positioner_interface, 1, id);
   wl_resource_set_implementation(
       host_xdg_positioner->resource, &sl_xdg_positioner_implementation,
       host_xdg_positioner, sl_destroy_host_xdg_positioner);
-  host_xdg_positioner->proxy = zxdg_shell_v6_create_positioner(host->proxy);
-  zxdg_positioner_v6_set_user_data(host_xdg_positioner->proxy,
-                                   host_xdg_positioner);
+  host_xdg_positioner->proxy = xdg_wm_base_create_positioner(host->proxy);
+  xdg_positioner_set_user_data(host_xdg_positioner->proxy, host_xdg_positioner);
 }
 
 static void sl_xdg_shell_get_xdg_surface(struct wl_client* client,
@@ -536,15 +531,15 @@ static void sl_xdg_shell_get_xdg_surface(struct wl_client* client,
 
   host_xdg_surface->ctx = host->ctx;
   host_xdg_surface->resource =
-      wl_resource_create(client, &zxdg_surface_v6_interface, 1, id);
+      wl_resource_create(client, &xdg_surface_interface, 1, id);
   wl_resource_set_implementation(host_xdg_surface->resource,
                                  &sl_xdg_surface_implementation,
                                  host_xdg_surface, sl_destroy_host_xdg_surface);
   host_xdg_surface->proxy =
-      zxdg_shell_v6_get_xdg_surface(host->proxy, host_surface->proxy);
-  zxdg_surface_v6_set_user_data(host_xdg_surface->proxy, host_xdg_surface);
-  zxdg_surface_v6_add_listener(host_xdg_surface->proxy,
-                               &sl_xdg_surface_listener, host_xdg_surface);
+      xdg_wm_base_get_xdg_surface(host->proxy, host_surface->proxy);
+  xdg_surface_set_user_data(host_xdg_surface->proxy, host_xdg_surface);
+  xdg_surface_add_listener(host_xdg_surface->proxy, &sl_xdg_surface_listener,
+                           host_xdg_surface);
   host_surface->has_role = 1;
 }
 
@@ -554,30 +549,30 @@ static void sl_xdg_shell_pong(struct wl_client* client,
   struct sl_host_xdg_shell* host =
       static_cast<sl_host_xdg_shell*>(wl_resource_get_user_data(resource));
 
-  zxdg_shell_v6_pong(host->proxy, serial);
+  xdg_wm_base_pong(host->proxy, serial);
 }
 
-static const struct zxdg_shell_v6_interface sl_xdg_shell_implementation = {
+static const struct xdg_wm_base_interface sl_xdg_shell_implementation = {
     sl_xdg_shell_destroy, sl_xdg_shell_create_positioner,
     sl_xdg_shell_get_xdg_surface, sl_xdg_shell_pong};
 
 static void sl_xdg_shell_ping(void* data,
-                              struct zxdg_shell_v6* xdg_shell,
+                              struct xdg_wm_base* xdg_shell,
                               uint32_t serial) {
   struct sl_host_xdg_shell* host =
-      static_cast<sl_host_xdg_shell*>(zxdg_shell_v6_get_user_data(xdg_shell));
+      static_cast<sl_host_xdg_shell*>(xdg_wm_base_get_user_data(xdg_shell));
 
-  zxdg_shell_v6_send_ping(host->resource, serial);
+  xdg_wm_base_send_ping(host->resource, serial);
 }
 
-static const struct zxdg_shell_v6_listener sl_xdg_shell_listener = {
+static const struct xdg_wm_base_listener sl_xdg_shell_listener = {
     sl_xdg_shell_ping};
 
 static void sl_destroy_host_xdg_shell(struct wl_resource* resource) {
   struct sl_host_xdg_shell* host =
       static_cast<sl_host_xdg_shell*>(wl_resource_get_user_data(resource));
 
-  zxdg_shell_v6_destroy(host->proxy);
+  xdg_wm_base_destroy(host->proxy);
   wl_resource_set_user_data(resource, NULL);
   free(host);
 }
@@ -591,17 +586,17 @@ static void sl_bind_host_xdg_shell(struct wl_client* client,
       static_cast<sl_host_xdg_shell*>(malloc(sizeof(*host)));
   assert(host);
   host->ctx = ctx;
-  host->resource = wl_resource_create(client, &zxdg_shell_v6_interface, 1, id);
+  host->resource = wl_resource_create(client, &xdg_wm_base_interface, 1, id);
   wl_resource_set_implementation(host->resource, &sl_xdg_shell_implementation,
                                  host, sl_destroy_host_xdg_shell);
-  host->proxy = static_cast<zxdg_shell_v6*>(
+  host->proxy = static_cast<xdg_wm_base*>(
       wl_registry_bind(wl_display_get_registry(ctx->display),
-                       ctx->xdg_shell->id, &zxdg_shell_v6_interface, 1));
-  zxdg_shell_v6_set_user_data(host->proxy, host);
-  zxdg_shell_v6_add_listener(host->proxy, &sl_xdg_shell_listener, host);
+                       ctx->xdg_shell->id, &xdg_wm_base_interface, 1));
+  xdg_wm_base_set_user_data(host->proxy, host);
+  xdg_wm_base_add_listener(host->proxy, &sl_xdg_shell_listener, host);
 }
 
 struct sl_global* sl_xdg_shell_global_create(struct sl_context* ctx) {
-  return sl_global_create(ctx, &zxdg_shell_v6_interface, 1, ctx,
+  return sl_global_create(ctx, &xdg_wm_base_interface, 1, ctx,
                           sl_bind_host_xdg_shell);
 }
diff --git a/vm_tools/sommelier/sommelier.cc b/vm_tools/sommelier/sommelier.cc
index 2833e52a61..8f53b3b65b 100644
--- a/vm_tools/sommelier/sommelier.cc
+++ b/vm_tools/sommelier/sommelier.cc
@@ -39,7 +39,7 @@
 #include "relative-pointer-unstable-v1-client-protocol.h"  // NOLINT(build/include_directory)
 #include "text-input-unstable-v1-client-protocol.h"  // NOLINT(build/include_directory)
 #include "viewporter-client-protocol.h"  // NOLINT(build/include_directory)
-#include "xdg-shell-unstable-v6-client-protocol.h"  // NOLINT(build/include_directory)
+#include "xdg-shell-client-protocol.h"  // NOLINT(build/include_directory)
 
 #define errno_assert(rv)                                          \
   {                                                               \
@@ -372,13 +372,13 @@ void sl_sync_point_destroy(struct sl_sync_point* sync_point) {
 }
 
 static void sl_internal_xdg_shell_ping(void* data,
-                                       struct zxdg_shell_v6* xdg_shell,
+                                       struct xdg_wm_base* xdg_shell,
                                        uint32_t serial) {
   TRACE_EVENT("shell", "sl_internal_xdg_shell_ping");
-  zxdg_shell_v6_pong(xdg_shell, serial);
+  xdg_wm_base_pong(xdg_shell, serial);
 }
 
-static const struct zxdg_shell_v6_listener sl_internal_xdg_shell_listener = {
+static const struct xdg_wm_base_listener sl_internal_xdg_shell_listener = {
     sl_internal_xdg_shell_ping};
 
 static void sl_send_configure_notify(struct sl_window* window) {
@@ -549,8 +549,8 @@ int sl_process_pending_configure_acks(struct sl_window* window,
   }
 
   if (window->xdg_surface) {
-    zxdg_surface_v6_ack_configure(window->xdg_surface,
-                                  window->pending_config.serial);
+    xdg_surface_ack_configure(window->xdg_surface,
+                              window->pending_config.serial);
   }
   window->pending_config.serial = 0;
 
@@ -567,11 +567,12 @@ void sl_commit(struct sl_window* window, struct sl_host_surface* host_surface) {
   }
 }
 
-static void sl_internal_xdg_surface_configure(
-    void* data, struct zxdg_surface_v6* xdg_surface, uint32_t serial) {
+static void sl_internal_xdg_surface_configure(void* data,
+                                              struct xdg_surface* xdg_surface,
+                                              uint32_t serial) {
   TRACE_EVENT("surface", "sl_internal_xdg_surface_configure");
   struct sl_window* window =
-      static_cast<sl_window*>(zxdg_surface_v6_get_user_data(xdg_surface));
+      static_cast<sl_window*>(xdg_surface_get_user_data(xdg_surface));
 
   window->next_config.serial = serial;
   if (!window->pending_config.serial) {
@@ -589,18 +590,18 @@ static void sl_internal_xdg_surface_configure(
   }
 }
 
-static const struct zxdg_surface_v6_listener sl_internal_xdg_surface_listener =
-    {sl_internal_xdg_surface_configure};
+static const struct xdg_surface_listener sl_internal_xdg_surface_listener = {
+    sl_internal_xdg_surface_configure};
 
 static void sl_internal_xdg_toplevel_configure(
     void* data,
-    struct zxdg_toplevel_v6* xdg_toplevel,
+    struct xdg_toplevel* xdg_toplevel,
     int32_t width,
     int32_t height,
     struct wl_array* states) {
   TRACE_EVENT("other", "sl_internal_xdg_toplevel_configure");
   struct sl_window* window =
-      static_cast<sl_window*>(zxdg_toplevel_v6_get_user_data(xdg_toplevel));
+      static_cast<sl_window*>(xdg_toplevel_get_user_data(xdg_toplevel));
   int activated = 0;
   uint32_t* state;
   int i = 0;
@@ -630,24 +631,24 @@ static void sl_internal_xdg_toplevel_configure(
 
   window->allow_resize = 1;
   sl_array_for_each(state, states) {
-    if (*state == ZXDG_TOPLEVEL_V6_STATE_FULLSCREEN) {
+    if (*state == XDG_TOPLEVEL_STATE_FULLSCREEN) {
       window->allow_resize = 0;
       window->next_config.states[i++] =
           window->ctx->atoms[ATOM_NET_WM_STATE_FULLSCREEN].value;
     }
-    if (*state == ZXDG_TOPLEVEL_V6_STATE_MAXIMIZED) {
+    if (*state == XDG_TOPLEVEL_STATE_MAXIMIZED) {
       window->allow_resize = 0;
       window->next_config.states[i++] =
           window->ctx->atoms[ATOM_NET_WM_STATE_MAXIMIZED_VERT].value;
       window->next_config.states[i++] =
           window->ctx->atoms[ATOM_NET_WM_STATE_MAXIMIZED_HORZ].value;
     }
-    if (*state == ZXDG_TOPLEVEL_V6_STATE_ACTIVATED) {
+    if (*state == XDG_TOPLEVEL_STATE_ACTIVATED) {
       activated = 1;
       window->next_config.states[i++] =
           window->ctx->atoms[ATOM_NET_WM_STATE_FOCUSED].value;
     }
-    if (*state == ZXDG_TOPLEVEL_V6_STATE_RESIZING)
+    if (*state == XDG_TOPLEVEL_STATE_RESIZING)
       window->allow_resize = 0;
   }
 
@@ -662,11 +663,11 @@ static void sl_internal_xdg_toplevel_configure(
   window->next_config.states_length = i;
 }
 
-static void sl_internal_xdg_toplevel_close(
-    void* data, struct zxdg_toplevel_v6* xdg_toplevel) {
+static void sl_internal_xdg_toplevel_close(void* data,
+                                           struct xdg_toplevel* xdg_toplevel) {
   TRACE_EVENT("other", "sl_internal_xdg_toplevel_close");
   struct sl_window* window =
-      static_cast<sl_window*>(zxdg_toplevel_v6_get_user_data(xdg_toplevel));
+      static_cast<sl_window*>(xdg_toplevel_get_user_data(xdg_toplevel));
   xcb_client_message_event_t event = {};
   event.response_type = XCB_CLIENT_MESSAGE;
   event.format = 32;
@@ -679,21 +680,20 @@ static void sl_internal_xdg_toplevel_close(
                  XCB_EVENT_MASK_NO_EVENT, (const char*)&event);
 }
 
-static const struct zxdg_toplevel_v6_listener
-    sl_internal_xdg_toplevel_listener = {sl_internal_xdg_toplevel_configure,
-                                         sl_internal_xdg_toplevel_close};
+static const struct xdg_toplevel_listener sl_internal_xdg_toplevel_listener = {
+    sl_internal_xdg_toplevel_configure, sl_internal_xdg_toplevel_close};
 
 static void sl_internal_xdg_popup_configure(void* data,
-                                            struct zxdg_popup_v6* xdg_popup,
+                                            struct xdg_popup* xdg_popup,
                                             int32_t x,
                                             int32_t y,
                                             int32_t width,
                                             int32_t height) {}
 
 static void sl_internal_xdg_popup_done(void* data,
-                                       struct zxdg_popup_v6* zxdg_popup_v6) {}
+                                       struct xdg_popup* xdg_popup) {}
 
-static const struct zxdg_popup_v6_listener sl_internal_xdg_popup_listener = {
+static const struct xdg_popup_listener sl_internal_xdg_popup_listener = {
     sl_internal_xdg_popup_configure, sl_internal_xdg_popup_done};
 
 static void sl_window_set_wm_state(struct sl_window* window, int state) {
@@ -765,15 +765,15 @@ void sl_window_update(struct sl_window* window) {
       window->aura_surface = NULL;
     }
     if (window->xdg_toplevel) {
-      zxdg_toplevel_v6_destroy(window->xdg_toplevel);
+      xdg_toplevel_destroy(window->xdg_toplevel);
       window->xdg_toplevel = NULL;
     }
     if (window->xdg_popup) {
-      zxdg_popup_v6_destroy(window->xdg_popup);
+      xdg_popup_destroy(window->xdg_popup);
       window->xdg_popup = NULL;
     }
     if (window->xdg_surface) {
-      zxdg_surface_v6_destroy(window->xdg_surface);
+      xdg_surface_destroy(window->xdg_surface);
       window->xdg_surface = NULL;
     }
     window->realized = 0;
@@ -849,11 +849,11 @@ void sl_window_update(struct sl_window* window) {
   }
 
   if (!window->xdg_surface) {
-    window->xdg_surface = zxdg_shell_v6_get_xdg_surface(
-        ctx->xdg_shell->internal, host_surface->proxy);
-    zxdg_surface_v6_set_user_data(window->xdg_surface, window);
-    zxdg_surface_v6_add_listener(window->xdg_surface,
-                                 &sl_internal_xdg_surface_listener, window);
+    window->xdg_surface = xdg_wm_base_get_xdg_surface(ctx->xdg_shell->internal,
+                                                      host_surface->proxy);
+    xdg_surface_set_user_data(window->xdg_surface, window);
+    xdg_surface_add_listener(window->xdg_surface,
+                             &sl_internal_xdg_surface_listener, window);
   }
 
   if (ctx->aura_shell) {
@@ -888,50 +888,46 @@ void sl_window_update(struct sl_window* window) {
   // window is closed.
   if (ctx->xwayland || !parent) {
     if (!window->xdg_toplevel) {
-      window->xdg_toplevel = zxdg_surface_v6_get_toplevel(window->xdg_surface);
-      zxdg_toplevel_v6_set_user_data(window->xdg_toplevel, window);
-      zxdg_toplevel_v6_add_listener(window->xdg_toplevel,
-                                    &sl_internal_xdg_toplevel_listener, window);
+      window->xdg_toplevel = xdg_surface_get_toplevel(window->xdg_surface);
+      xdg_toplevel_set_user_data(window->xdg_toplevel, window);
+      xdg_toplevel_add_listener(window->xdg_toplevel,
+                                &sl_internal_xdg_toplevel_listener, window);
     }
     if (parent)
-      zxdg_toplevel_v6_set_parent(window->xdg_toplevel, parent->xdg_toplevel);
+      xdg_toplevel_set_parent(window->xdg_toplevel, parent->xdg_toplevel);
     if (window->name)
-      zxdg_toplevel_v6_set_title(window->xdg_toplevel, window->name);
+      xdg_toplevel_set_title(window->xdg_toplevel, window->name);
     if (window->size_flags & P_MIN_SIZE) {
-      zxdg_toplevel_v6_set_min_size(window->xdg_toplevel,
-                                    window->min_width / ctx->scale,
-                                    window->min_height / ctx->scale);
+      xdg_toplevel_set_min_size(window->xdg_toplevel,
+                                window->min_width / ctx->scale,
+                                window->min_height / ctx->scale);
     }
     if (window->size_flags & P_MAX_SIZE) {
-      zxdg_toplevel_v6_set_max_size(window->xdg_toplevel,
-                                    window->max_width / ctx->scale,
-                                    window->max_height / ctx->scale);
+      xdg_toplevel_set_max_size(window->xdg_toplevel,
+                                window->max_width / ctx->scale,
+                                window->max_height / ctx->scale);
     }
     if (window->maximized) {
-      zxdg_toplevel_v6_set_maximized(window->xdg_toplevel);
+      xdg_toplevel_set_maximized(window->xdg_toplevel);
     }
   } else if (!window->xdg_popup) {
-    struct zxdg_positioner_v6* positioner;
+    struct xdg_positioner* positioner;
 
-    positioner = zxdg_shell_v6_create_positioner(ctx->xdg_shell->internal);
+    positioner = xdg_wm_base_create_positioner(ctx->xdg_shell->internal);
     assert(positioner);
-    zxdg_positioner_v6_set_anchor(
-        positioner,
-        ZXDG_POSITIONER_V6_ANCHOR_TOP | ZXDG_POSITIONER_V6_ANCHOR_LEFT);
-    zxdg_positioner_v6_set_gravity(
-        positioner,
-        ZXDG_POSITIONER_V6_GRAVITY_BOTTOM | ZXDG_POSITIONER_V6_GRAVITY_RIGHT);
-    zxdg_positioner_v6_set_anchor_rect(
-        positioner, (window->x - parent->x) / ctx->scale,
-        (window->y - parent->y) / ctx->scale, 1, 1);
+    xdg_positioner_set_anchor(positioner, XDG_POSITIONER_ANCHOR_TOP_LEFT);
+    xdg_positioner_set_gravity(positioner, XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT);
+    xdg_positioner_set_anchor_rect(positioner,
+                                   (window->x - parent->x) / ctx->scale,
+                                   (window->y - parent->y) / ctx->scale, 1, 1);
 
-    window->xdg_popup = zxdg_surface_v6_get_popup(
-        window->xdg_surface, parent->xdg_surface, positioner);
-    zxdg_popup_v6_set_user_data(window->xdg_popup, window);
-    zxdg_popup_v6_add_listener(window->xdg_popup,
-                               &sl_internal_xdg_popup_listener, window);
+    window->xdg_popup = xdg_surface_get_popup(window->xdg_surface,
+                                              parent->xdg_surface, positioner);
+    xdg_popup_set_user_data(window->xdg_popup, window);
+    xdg_popup_add_listener(window->xdg_popup, &sl_internal_xdg_popup_listener,
+                           window);
 
-    zxdg_positioner_v6_destroy(positioner);
+    xdg_positioner_destroy(positioner);
   }
 
   if ((window->size_flags & (US_POSITION | P_POSITION)) && parent &&
@@ -1332,7 +1328,7 @@ static void sl_registry_handler(void* data,
       data_device_manager->host_global =
           sl_data_device_manager_global_create(ctx);
     }
-  } else if (strcmp(interface, "zxdg_shell_v6") == 0) {
+  } else if (strcmp(interface, "xdg_wm_base") == 0) {
     struct sl_xdg_shell* xdg_shell =
         static_cast<sl_xdg_shell*>(malloc(sizeof(struct sl_xdg_shell)));
     assert(xdg_shell);
@@ -1343,10 +1339,10 @@ static void sl_registry_handler(void* data,
     assert(!ctx->xdg_shell);
     ctx->xdg_shell = xdg_shell;
     if (ctx->xwayland) {
-      xdg_shell->internal = static_cast<zxdg_shell_v6*>(
-          wl_registry_bind(registry, id, &zxdg_shell_v6_interface, 1));
-      zxdg_shell_v6_add_listener(xdg_shell->internal,
-                                 &sl_internal_xdg_shell_listener, NULL);
+      xdg_shell->internal = static_cast<xdg_wm_base*>(
+          wl_registry_bind(registry, id, &xdg_wm_base_interface, 1));
+      xdg_wm_base_add_listener(xdg_shell->internal,
+                               &sl_internal_xdg_shell_listener, NULL);
     } else {
       xdg_shell->host_global = sl_xdg_shell_global_create(ctx);
     }
@@ -1479,7 +1475,7 @@ static void sl_registry_remover(void* data,
     if (ctx->xdg_shell->host_global)
       sl_global_destroy(ctx->xdg_shell->host_global);
     if (ctx->xdg_shell->internal)
-      zxdg_shell_v6_destroy(ctx->xdg_shell->internal);
+      xdg_wm_base_destroy(ctx->xdg_shell->internal);
     free(ctx->xdg_shell);
     ctx->xdg_shell = NULL;
     return;
@@ -1656,11 +1652,11 @@ static void sl_destroy_window(struct sl_window* window) {
   }
 
   if (window->xdg_popup)
-    zxdg_popup_v6_destroy(window->xdg_popup);
+    xdg_popup_destroy(window->xdg_popup);
   if (window->xdg_toplevel)
-    zxdg_toplevel_v6_destroy(window->xdg_toplevel);
+    xdg_toplevel_destroy(window->xdg_toplevel);
   if (window->xdg_surface)
-    zxdg_surface_v6_destroy(window->xdg_surface);
+    xdg_surface_destroy(window->xdg_surface);
   if (window->aura_surface)
     zaura_surface_destroy(window->aura_surface);
 
@@ -2124,15 +2120,15 @@ static void sl_handle_configure_request(struct sl_context* ctx,
   // that matching contents will arrive.
   if (window->xdg_toplevel) {
     if (window->pending_config.serial) {
-      zxdg_surface_v6_ack_configure(window->xdg_surface,
-                                    window->pending_config.serial);
+      xdg_surface_ack_configure(window->xdg_surface,
+                                window->pending_config.serial);
       window->pending_config.serial = 0;
       window->pending_config.mask = 0;
       window->pending_config.states_length = 0;
     }
     if (window->next_config.serial) {
-      zxdg_surface_v6_ack_configure(window->xdg_surface,
-                                    window->next_config.serial);
+      xdg_surface_ack_configure(window->xdg_surface,
+                                window->next_config.serial);
       window->next_config.serial = 0;
       window->next_config.mask = 0;
       window->next_config.states_length = 0;
@@ -2253,23 +2249,23 @@ static void sl_handle_configure_notify(struct sl_context* ctx,
 static uint32_t sl_resize_edge(int net_wm_moveresize_size) {
   switch (net_wm_moveresize_size) {
     case NET_WM_MOVERESIZE_SIZE_TOPLEFT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_LEFT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT;
     case NET_WM_MOVERESIZE_SIZE_TOP:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP;
+      return XDG_TOPLEVEL_RESIZE_EDGE_TOP;
     case NET_WM_MOVERESIZE_SIZE_TOPRIGHT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_RIGHT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT;
     case NET_WM_MOVERESIZE_SIZE_RIGHT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_RIGHT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_RIGHT;
     case NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_RIGHT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT;
     case NET_WM_MOVERESIZE_SIZE_BOTTOM:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM;
+      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
     case NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_LEFT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT;
     case NET_WM_MOVERESIZE_SIZE_LEFT:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_LEFT;
+      return XDG_TOPLEVEL_RESIZE_EDGE_LEFT;
     default:
-      return ZXDG_TOPLEVEL_V6_RESIZE_EDGE_NONE;
+      return XDG_TOPLEVEL_RESIZE_EDGE_NONE;
   }
 }
 
@@ -2368,16 +2364,16 @@ static void sl_handle_client_message(struct sl_context* ctx,
         return;
 
       if (event->data.data32[2] == NET_WM_MOVERESIZE_MOVE) {
-        zxdg_toplevel_v6_move(window->xdg_toplevel, seat->proxy,
-                              seat->seat->last_serial);
+        xdg_toplevel_move(window->xdg_toplevel, seat->proxy,
+                          seat->seat->last_serial);
       } else {
         uint32_t edge = sl_resize_edge(event->data.data32[2]);
 
-        if (edge == ZXDG_TOPLEVEL_V6_RESIZE_EDGE_NONE)
+        if (edge == XDG_TOPLEVEL_RESIZE_EDGE_NONE)
           return;
 
-        zxdg_toplevel_v6_resize(window->xdg_toplevel, seat->proxy,
-                                seat->seat->last_serial, edge);
+        xdg_toplevel_resize(window->xdg_toplevel, seat->proxy,
+                            seat->seat->last_serial, edge);
       }
     }
   } else if (event->type == ctx->atoms[ATOM_NET_WM_STATE].value) {
@@ -2398,9 +2394,9 @@ static void sl_handle_client_message(struct sl_context* ctx,
                     "action", net_wm_state_to_string(action), "window->name",
                     window->name);
         if (action == NET_WM_STATE_ADD)
-          zxdg_toplevel_v6_set_fullscreen(window->xdg_toplevel, NULL);
+          xdg_toplevel_set_fullscreen(window->xdg_toplevel, NULL);
         else if (action == NET_WM_STATE_REMOVE)
-          zxdg_toplevel_v6_unset_fullscreen(window->xdg_toplevel);
+          xdg_toplevel_unset_fullscreen(window->xdg_toplevel);
       }
 
       if (changed[ATOM_NET_WM_STATE_MAXIMIZED_VERT] &&
@@ -2411,9 +2407,9 @@ static void sl_handle_client_message(struct sl_context* ctx,
             "action", net_wm_state_to_string(action), "window->name",
             window->name);
         if (action == NET_WM_STATE_ADD)
-          zxdg_toplevel_v6_set_maximized(window->xdg_toplevel);
+          xdg_toplevel_set_maximized(window->xdg_toplevel);
         else if (action == NET_WM_STATE_REMOVE)
-          zxdg_toplevel_v6_unset_maximized(window->xdg_toplevel);
+          xdg_toplevel_unset_maximized(window->xdg_toplevel);
       }
     }
   } else if (event->type == ctx->atoms[ATOM_WM_CHANGE_STATE].value &&
@@ -2422,7 +2418,7 @@ static void sl_handle_client_message(struct sl_context* ctx,
     TRACE_EVENT("x11wm", "XCB_CLIENT_MESSAGE: WM_STATE_ICONIC (minimize)",
                 "window->name", window ? window->name : "<unknown>");
     if (window && window->xdg_toplevel) {
-      zxdg_toplevel_v6_set_minimized(window->xdg_toplevel);
+      xdg_toplevel_set_minimized(window->xdg_toplevel);
     }
   }
 }
@@ -2435,7 +2431,7 @@ static void sl_handle_focus_in(struct sl_context* ctx,
     // window was realized.
     struct sl_window* parent = sl_lookup_window(ctx, window->transient_for);
     if (parent && parent->xdg_toplevel && window->xdg_toplevel)
-      zxdg_toplevel_v6_set_parent(window->xdg_toplevel, parent->xdg_toplevel);
+      xdg_toplevel_set_parent(window->xdg_toplevel, parent->xdg_toplevel);
   }
 }
 
@@ -2744,9 +2740,9 @@ static void sl_handle_property_notify(struct sl_context* ctx,
       return;
 
     if (window->name) {
-      zxdg_toplevel_v6_set_title(window->xdg_toplevel, window->name);
+      xdg_toplevel_set_title(window->xdg_toplevel, window->name);
     } else {
-      zxdg_toplevel_v6_set_title(window->xdg_toplevel, "");
+      xdg_toplevel_set_title(window->xdg_toplevel, "");
     }
   } else if (event->atom == XCB_ATOM_WM_CLASS) {
     struct sl_window* window = sl_lookup_window(ctx, event->window);
@@ -2802,19 +2798,19 @@ static void sl_handle_property_notify(struct sl_context* ctx,
       return;
 
     if (window->size_flags & P_MIN_SIZE) {
-      zxdg_toplevel_v6_set_min_size(window->xdg_toplevel,
-                                    window->min_width / ctx->scale,
-                                    window->min_height / ctx->scale);
+      xdg_toplevel_set_min_size(window->xdg_toplevel,
+                                window->min_width / ctx->scale,
+                                window->min_height / ctx->scale);
     } else {
-      zxdg_toplevel_v6_set_min_size(window->xdg_toplevel, 0, 0);
+      xdg_toplevel_set_min_size(window->xdg_toplevel, 0, 0);
     }
 
     if (window->size_flags & P_MAX_SIZE) {
-      zxdg_toplevel_v6_set_max_size(window->xdg_toplevel,
-                                    window->max_width / ctx->scale,
-                                    window->max_height / ctx->scale);
+      xdg_toplevel_set_max_size(window->xdg_toplevel,
+                                window->max_width / ctx->scale,
+                                window->max_height / ctx->scale);
     } else {
-      zxdg_toplevel_v6_set_max_size(window->xdg_toplevel, 0, 0);
+      xdg_toplevel_set_max_size(window->xdg_toplevel, 0, 0);
     }
   } else if (event->atom == XCB_ATOM_WM_HINTS) {
     struct sl_window* window = sl_lookup_window(ctx, event->window);
diff --git a/vm_tools/sommelier/sommelier.h b/vm_tools/sommelier/sommelier.h
index 79bcf6a3b3..d3157cd8a9 100644
--- a/vm_tools/sommelier/sommelier.h
+++ b/vm_tools/sommelier/sommelier.h
@@ -400,7 +400,7 @@ struct sl_xdg_shell {
   struct sl_context* ctx;
   uint32_t id;
   struct sl_global* host_global;
-  struct zxdg_shell_v6* internal;
+  struct xdg_wm_base* internal;
 };
 
 struct sl_aura_shell {
@@ -500,9 +500,9 @@ struct sl_window {
   int max_height;
   struct sl_config next_config;
   struct sl_config pending_config;
-  struct zxdg_surface_v6* xdg_surface;
-  struct zxdg_toplevel_v6* xdg_toplevel;
-  struct zxdg_popup_v6* xdg_popup;
+  struct xdg_surface* xdg_surface;
+  struct xdg_toplevel* xdg_toplevel;
+  struct xdg_popup* xdg_popup;
   struct zaura_surface* aura_surface;
   struct wl_list link;
 };
-- 
2.31.1

